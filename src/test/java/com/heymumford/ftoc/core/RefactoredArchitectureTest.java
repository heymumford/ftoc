package com.heymumford.ftoc.core;

import com.heymumford.ftoc.FtocUtilityRefactored;
import com.heymumford.ftoc.core.impl.DefaultFeatureProcessor;
import com.heymumford.ftoc.core.impl.DefaultFeatureRepository;
import com.heymumford.ftoc.core.impl.DefaultReporter;
import com.heymumford.ftoc.model.Feature;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Consumer;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Tests for the refactored architecture with proper separation of concerns.
 */
@Disabled("Temporarily disabled until JUnit issues are fixed")
public class RefactoredArchitectureTest {
    
    @TempDir
    Path tempDir;
    
    private FeatureRepository mockRepository;
    private FeatureProcessor mockProcessor;
    private Reporter mockReporter;
    private FtocUtilityRefactored ftoc;
    
    @BeforeEach
    void setUp() {
        mockRepository = mock(FeatureRepository.class);
        mockProcessor = mock(FeatureProcessor.class);
        mockReporter = mock(Reporter.class);
        
        ftoc = new FtocUtilityRefactored(mockRepository, mockProcessor, mockReporter);
    }
    
    @Test
    void testProcessDirectory() {
        // Prepare mocks
        Path directory = Paths.get("/test/dir");
        List<Path> featurePaths = Collections.singletonList(Paths.get("/test/dir/test.feature"));
        Feature mockFeature = new Feature("/test/dir/test.feature");
        mockFeature.setName("Test Feature");
        List<Feature> features = Collections.singletonList(mockFeature);
        Map<String, Integer> tagConcordance = Collections.singletonMap("@Test", 1);
        
        when(mockRepository.findFeatureFiles(directory)).thenReturn(featurePaths);
        when(mockProcessor.processFeatures(eq(featurePaths), anyBoolean())).thenReturn(features);
        when(mockProcessor.generateTagConcordance(features)).thenReturn(tagConcordance);
        when(mockProcessor.shouldUseParallelProcessing(anyInt())).thenReturn(false);
        
        // Execute
        ftoc.processDirectory("/test/dir");
        
        // Verify
        verify(mockRepository).findFeatureFiles(directory);
        verify(mockProcessor).processFeatures(eq(featurePaths), anyBoolean());
        verify(mockProcessor).generateTagConcordance(features);
        verify(mockReporter).generateConcordanceReport(tagConcordance, features, Reporter.Format.PLAIN_TEXT);
        verify(mockReporter).generateTableOfContents(features, Reporter.Format.PLAIN_TEXT, 
                Collections.emptyList(), Collections.emptyList());
        
        // Verify that the analytics reports are not generated by default
        verify(mockReporter, never()).generateTagQualityReport(
                any(List.class), any(Map.class), any(Reporter.Format.class));
        verify(mockReporter, never()).generateAntiPatternReport(
                any(List.class), any(Reporter.Format.class));
    }
    
    @Test
    void testProcessDirectoryWithAnalytics() {
        // Prepare mocks
        Path directory = Paths.get("/test/dir");
        List<Path> featurePaths = Collections.singletonList(Paths.get("/test/dir/test.feature"));
        Feature mockFeature = new Feature("/test/dir/test.feature");
        mockFeature.setName("Test Feature");
        List<Feature> features = Collections.singletonList(mockFeature);
        Map<String, Integer> tagConcordance = Collections.singletonMap("@Test", 1);
        
        when(mockRepository.findFeatureFiles(directory)).thenReturn(featurePaths);
        when(mockProcessor.processFeatures(eq(featurePaths), anyBoolean())).thenReturn(features);
        when(mockProcessor.generateTagConcordance(features)).thenReturn(tagConcordance);
        when(mockProcessor.shouldUseParallelProcessing(anyInt())).thenReturn(false);
        
        // Enable analytics
        ftoc.setAnalyzeTagQuality(true);
        ftoc.setDetectAntiPatterns(true);
        
        // Execute
        ftoc.processDirectory("/test/dir");
        
        // Verify
        verify(mockRepository).findFeatureFiles(directory);
        verify(mockProcessor).processFeatures(eq(featurePaths), anyBoolean());
        verify(mockProcessor).generateTagConcordance(features);
        verify(mockReporter).generateConcordanceReport(tagConcordance, features, Reporter.Format.PLAIN_TEXT);
        verify(mockReporter).generateTableOfContents(features, Reporter.Format.PLAIN_TEXT, 
                Collections.emptyList(), Collections.emptyList());
        
        // Verify that analytics reports are generated
        verify(mockReporter).generateTagQualityReport(features, tagConcordance, Reporter.Format.PLAIN_TEXT);
        verify(mockReporter).generateAntiPatternReport(features, Reporter.Format.PLAIN_TEXT);
    }
    
    @Test
    void testConcordanceOnlyMode() {
        // Prepare mocks
        Path directory = Paths.get("/test/dir");
        List<Path> featurePaths = Collections.singletonList(Paths.get("/test/dir/test.feature"));
        Feature mockFeature = new Feature("/test/dir/test.feature");
        mockFeature.setName("Test Feature");
        List<Feature> features = Collections.singletonList(mockFeature);
        Map<String, Integer> tagConcordance = Collections.singletonMap("@Test", 1);
        
        when(mockRepository.findFeatureFiles(directory)).thenReturn(featurePaths);
        when(mockProcessor.processFeatures(eq(featurePaths), anyBoolean())).thenReturn(features);
        when(mockProcessor.generateTagConcordance(features)).thenReturn(tagConcordance);
        when(mockProcessor.shouldUseParallelProcessing(anyInt())).thenReturn(false);
        
        // Execute in concordance-only mode
        ftoc.processDirectory("/test/dir", true);
        
        // Verify
        verify(mockRepository).findFeatureFiles(directory);
        verify(mockProcessor).processFeatures(eq(featurePaths), anyBoolean());
        verify(mockProcessor).generateTagConcordance(features);
        verify(mockReporter).generateConcordanceReport(tagConcordance, features, Reporter.Format.PLAIN_TEXT);
        
        // Verify that TOC is not generated in concordance-only mode
        verify(mockReporter, never()).generateTableOfContents(
                any(List.class), any(Reporter.Format.class), any(List.class), any(List.class));
    }
    
    @Test
    void testTagFilters() {
        // Add tag filters
        ftoc.addIncludeTagFilter("@P0");
        ftoc.addIncludeTagFilter("Smoke"); // Should add @ prefix
        ftoc.addExcludeTagFilter("@Flaky");
        
        // Prepare mocks
        Path directory = Paths.get("/test/dir");
        List<Path> featurePaths = Collections.singletonList(Paths.get("/test/dir/test.feature"));
        Feature mockFeature = new Feature("/test/dir/test.feature");
        mockFeature.setName("Test Feature");
        List<Feature> features = Collections.singletonList(mockFeature);
        Map<String, Integer> tagConcordance = Collections.singletonMap("@Test", 1);
        
        when(mockRepository.findFeatureFiles(directory)).thenReturn(featurePaths);
        when(mockProcessor.processFeatures(eq(featurePaths), anyBoolean())).thenReturn(features);
        when(mockProcessor.generateTagConcordance(features)).thenReturn(tagConcordance);
        when(mockProcessor.shouldUseParallelProcessing(anyInt())).thenReturn(false);
        
        // Execute
        ftoc.processDirectory("/test/dir");
        
        // Verify tag filters are applied to TOC
        List<String> expectedIncludes = List.of("@P0", "@Smoke");
        List<String> expectedExcludes = List.of("@Flaky");
        
        verify(mockReporter).generateTableOfContents(features, Reporter.Format.PLAIN_TEXT, 
                expectedIncludes, expectedExcludes);
        
        // Clear filters and verify
        ftoc.clearTagFilters();
        ftoc.processDirectory("/test/dir");
        
        verify(mockReporter).generateTableOfContents(features, Reporter.Format.PLAIN_TEXT, 
                Collections.emptyList(), Collections.emptyList());
    }
    
    @Test
    void testOutputFormat() {
        // Change output format
        ftoc.setOutputFormat(Reporter.Format.MARKDOWN);
        
        // Prepare mocks
        Path directory = Paths.get("/test/dir");
        List<Path> featurePaths = Collections.singletonList(Paths.get("/test/dir/test.feature"));
        Feature mockFeature = new Feature("/test/dir/test.feature");
        mockFeature.setName("Test Feature");
        List<Feature> features = Collections.singletonList(mockFeature);
        Map<String, Integer> tagConcordance = Collections.singletonMap("@Test", 1);
        
        when(mockRepository.findFeatureFiles(directory)).thenReturn(featurePaths);
        when(mockProcessor.processFeatures(eq(featurePaths), anyBoolean())).thenReturn(features);
        when(mockProcessor.generateTagConcordance(features)).thenReturn(tagConcordance);
        when(mockProcessor.shouldUseParallelProcessing(anyInt())).thenReturn(false);
        
        // Execute
        ftoc.processDirectory("/test/dir");
        
        // Verify format is applied to all reports
        verify(mockReporter).generateConcordanceReport(tagConcordance, features, Reporter.Format.MARKDOWN);
        verify(mockReporter).generateTableOfContents(features, Reporter.Format.MARKDOWN, 
                Collections.emptyList(), Collections.emptyList());
    }
    
    @Test
    void testIntegrationWithDefaultImplementations() throws IOException {
        // Create a test feature file
        File featureFile = tempDir.resolve("test.feature").toFile();
        Files.writeString(featureFile.toPath(), 
                "Feature: Test Feature\n" +
                "  @P0 @Test\n" +
                "  Scenario: Test Scenario\n" +
                "    Given I have a test\n" +
                "    When I run the test\n" +
                "    Then the test passes\n");
        
        // Create real components
        FeatureRepository repository = new DefaultFeatureRepository();
        FeatureProcessor processor = new DefaultFeatureProcessor(repository);
        
        // Use a custom reporter that captures output
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        PrintStream printStream = new PrintStream(outputStream);
        
        Reporter reporter = new DefaultReporter();
        reporter.setOutputHandler(printStream::println);
        
        // Create utility with real components
        FtocUtilityRefactored ftoc = new FtocUtilityRefactored(repository, processor, reporter);
        
        // Process the directory
        ftoc.processDirectory(tempDir.toString());
        
        // Verify output contains expected content
        String output = outputStream.toString();
        assertTrue(output.contains("Test Feature"));
        assertTrue(output.contains("Test Scenario"));
        assertTrue(output.contains("@P0"));
        assertTrue(output.contains("@Test"));
    }
    
    @Test
    void testDefaultConstructor() {
        // The default constructor should create valid instances of all components
        FtocUtilityRefactored ftoc = new FtocUtilityRefactored();
        
        // We can't directly verify the internal components, but we can verify
        // that the utility initializes without errors
        assertDoesNotThrow(() -> ftoc.initialize());
    }
}